{
  "version": 3,
  "sources": ["../../src/lib/objects.ts"],
  "sourcesContent": ["import {\n\tCommandClasses,\n\tDuration,\n\tenumValuesToMetadataStates,\n\tNODE_ID_BROADCAST,\n\tSecurityClass,\n\tValueID,\n\tValueMetadata,\n} from \"@zwave-js/core\";\nimport { entries } from \"alcalzone-shared/objects\";\nimport { padStart } from \"alcalzone-shared/strings\";\nimport { isArray, isObject } from \"alcalzone-shared/typeguards\";\nimport { ControllerStatistics, RFRegion } from \"zwave-js\";\nimport type { ZWaveNotificationCallbackArgs_NotificationCC } from \"zwave-js/CommandClass\";\nimport {\n\tNodeStatistics,\n\tNodeStatus,\n\tVirtualNode,\n\tVirtualValueID,\n\tZWaveNode,\n} from \"zwave-js/Node\";\nimport type {\n\tTranslatedValueID,\n\tValueMetadataNumeric,\n\tValueType,\n\tZWaveNodeMetadataUpdatedArgs,\n\tZWaveNodeValueAddedArgs,\n\tZWaveNodeValueNotificationArgs,\n\tZWaveNodeValueRemovedArgs,\n\tZWaveNodeValueUpdatedArgs,\n} from \"zwave-js/Values\";\nimport { Global as _ } from \"./global\";\nimport { buffer2hex, computeDeviceId, getErrorMessage } from \"./shared\";\n\ntype ZWaveNodeArgs =\n\t| ZWaveNodeValueAddedArgs\n\t| ZWaveNodeValueUpdatedArgs\n\t| ZWaveNodeValueRemovedArgs\n\t| ZWaveNodeValueNotificationArgs\n\t| ZWaveNodeMetadataUpdatedArgs;\n\nexport function nodeStatusToStatusState(status: NodeStatus): string {\n\tswitch (status) {\n\t\tcase NodeStatus.Awake:\n\t\t\treturn \"awake\";\n\t\tcase NodeStatus.Asleep:\n\t\t\treturn \"asleep\";\n\t\tcase NodeStatus.Alive:\n\t\t\treturn \"alive\";\n\t\tcase NodeStatus.Dead:\n\t\t\treturn \"dead\";\n\t\tcase NodeStatus.Unknown:\n\t\t\treturn \"unknown\";\n\t}\n}\n\nfunction safeValue(value: unknown): ioBroker.StateValue {\n\tif (value == undefined) return null;\n\tif (Buffer.isBuffer(value)) {\n\t\t// We cannot store Buffers in ioBroker, encode them as HEX\n\t\treturn buffer2hex(value);\n\t} else if (isArray(value) || isObject(value)) {\n\t\t// ioBroker requires all arrays and objects to be stringified\n\t\treturn JSON.stringify(value);\n\t}\n\treturn value as any;\n}\n\nconst isCamelCasedSafeNameRegex = /^(?!.*[\\-_]$)[a-z]([a-zA-Z0-9\\-_]+)$/;\n\nexport const DEVICE_ID_BROADCAST = \"Broadcast\";\n\n/** Converts a device label to a valid filename */\nexport function nameToStateId(label: string): string {\n\tif (isCamelCasedSafeNameRegex.test(label)) return label;\n\tlet safeName = label;\n\t// Since these rules influence each other, we need to do multiple passes\n\twhile (true) {\n\t\tlet replaced = safeName;\n\t\t// Remove trailing, leading and multiple whitespace\n\t\treplaced = replaced.trim();\n\t\treplaced = replaced.replace(/\\s+/g, \" \");\n\t\t// Replace all unsafe chars\n\t\treplaced = replaced.replace(/[^a-zA-Z0-9\\-_ ]+/g, \"_\");\n\t\t// Replace spaces surrounded by unsafe chars with a space\n\t\treplaced = replaced.replace(/_\\s/g, \" \");\n\t\treplaced = replaced.replace(/\\s_/g, \" \");\n\t\t// Remove trailing and leading dashes and underscores\n\t\treplaced = replaced.replace(/^_\\s*/, \"\");\n\t\treplaced = replaced.replace(/\\s*_$/, \"\");\n\t\t// If nothing changed, we're done\n\t\tif (safeName === replaced) break;\n\t\t// Otherwise remember the intermediate result for the next pass\n\t\tsafeName = replaced;\n\t}\n\treturn camelCase(safeName);\n}\n\nfunction camelCase(str: string): string {\n\treturn str\n\t\t.split(\" \")\n\t\t.map((substr, i) =>\n\t\t\ti === 0\n\t\t\t\t? substr.toLowerCase()\n\t\t\t\t: substr[0].toUpperCase() + substr.slice(1).toLowerCase(),\n\t\t)\n\t\t.join(\"\");\n}\n\nexport function ccNameToChannelIdFragment(ccName: string): string {\n\treturn ccName.replace(/[\\s]+/g, \"_\");\n}\n\nfunction computeChannelIdInternal(prefix: string, ccName: string): string {\n\treturn `${prefix}.${ccNameToChannelIdFragment(ccName)}`;\n}\n\nexport function computeChannelId(nodeId: number, ccName: string): string {\n\treturn computeChannelIdInternal(computeDeviceId(nodeId), ccName);\n}\n\nexport function computeVirtualChannelId(\n\tprefix: string,\n\tccName: string,\n): string {\n\treturn computeChannelIdInternal(prefix, ccName);\n}\n\nfunction computeStateIdInternal(\n\tprefix: string,\n\targs: TranslatedValueID,\n): string {\n\treturn [\n\t\tprefix,\n\t\tccNameToChannelIdFragment(args.commandClassName),\n\t\t[\n\t\t\targs.propertyName?.trim() && nameToStateId(args.propertyName),\n\t\t\targs.endpoint && padStart(args.endpoint.toString(), 3, \"0\"),\n\t\t\targs.propertyKeyName?.trim() && nameToStateId(args.propertyKeyName),\n\t\t]\n\t\t\t.filter((s) => !!s)\n\t\t\t.join(\"_\"),\n\t].join(\".\");\n}\n\nexport function computeStateId(\n\tnodeId: number,\n\targs: TranslatedValueID,\n): string {\n\treturn computeStateIdInternal(computeDeviceId(nodeId), args);\n}\n\nexport function computeVirtualStateId(\n\tprefix: string,\n\targs: TranslatedValueID,\n): string {\n\treturn computeStateIdInternal(prefix, args);\n}\n\nconst secClassDefinitions = [\n\t[SecurityClass.S2_AccessControl, CommandClasses[\"Security 2\"]],\n\t[SecurityClass.S2_Authenticated, CommandClasses[\"Security 2\"]],\n\t[SecurityClass.S2_Unauthenticated, CommandClasses[\"Security 2\"]],\n\t[SecurityClass.S0_Legacy, CommandClasses[\"Security\"]],\n] as const;\n\nfunction securityClassesToRecord(node: ZWaveNode): Record<string, boolean> {\n\tconst ret = {} as Record<string, boolean>;\n\tfor (const [secClass, cc] of secClassDefinitions) {\n\t\tif (!node.supportsCC(cc)) continue;\n\t\tret[SecurityClass[secClass]] = node.hasSecurityClass(secClass) === true;\n\t}\n\treturn ret;\n}\n\nfunction nodeToNative(node: ZWaveNode): Record<string, any> {\n\treturn {\n\t\tid: node.id,\n\t\tisControllerNode: node.isControllerNode(),\n\t\tmanufacturerId: node.manufacturerId,\n\t\tproductType: node.productType,\n\t\tproductId: node.productId,\n\t\t...(node.deviceClass && {\n\t\t\ttype: {\n\t\t\t\tbasic: node.deviceClass.basic.label,\n\t\t\t\tgeneric: node.deviceClass.generic.label,\n\t\t\t\t...(node.deviceClass.specific.key !== 0x00\n\t\t\t\t\t? // Only use the the specific device class if it is not \"Unused\"\n\t\t\t\t\t  { specific: node.deviceClass.specific.label }\n\t\t\t\t\t: {}),\n\t\t\t},\n\t\t}),\n\t\t// endpoints: node.getEndpointCount(),\n\t\tendpointIndizes: node.getEndpointIndizes(),\n\t\tsecurityClasses: securityClassesToRecord(node),\n\t\tsecure: node.isSecure,\n\t\tsupportsFirmwareUpdate: node.supportsCC(\n\t\t\tCommandClasses[\"Firmware Update Meta Data\"],\n\t\t),\n\t};\n}\n\nfunction nodeToCommon(\n\tnode: ZWaveNode,\n): ioBroker.DeviceCommon & { name: string | undefined } {\n\treturn {\n\t\tname: node.deviceConfig\n\t\t\t? `${node.deviceConfig.manufacturer} ${node.deviceConfig.label}`\n\t\t\t: `Node ${padStart(node.id.toString(), 3, \"0\")}`,\n\t};\n}\n\nconst fallbackNodeNameRegex = /^Node \\d+$/;\n\nexport async function extendNode(node: ZWaveNode): Promise<void> {\n\tconst deviceId = computeDeviceId(node.id);\n\tconst originalObject = _.adapter.oObjects[\n\t\t`${_.adapter.namespace}.${deviceId}`\n\t] as ioBroker.DeviceObject | undefined;\n\n\t// update the object while preserving the existing common properties\n\tconst nodeCommon = nodeToCommon(node);\n\t// Overwrite empty names and placeholder/fallback names\n\tlet newName = originalObject?.common.name as string | undefined;\n\tnewName =\n\t\tnewName && !fallbackNodeNameRegex.test(newName)\n\t\t\t? newName\n\t\t\t: nodeCommon.name;\n\n\tconst desiredObject: ioBroker.SettableObject = {\n\t\ttype: \"device\",\n\t\tcommon: {\n\t\t\t...nodeCommon,\n\t\t\t...originalObject?.common,\n\t\t\tname: newName,\n\t\t},\n\t\tnative: nodeToNative(node),\n\t};\n\n\tawait setOrExtendObject(deviceId, desiredObject, originalObject);\n}\n\nexport async function ensureBroadcastNode(): Promise<void> {\n\tconst deviceId = DEVICE_ID_BROADCAST;\n\tconst originalObject = _.adapter.oObjects[\n\t\t`${_.adapter.namespace}.${deviceId}`\n\t] as ioBroker.DeviceObject | undefined;\n\n\tconst desiredObject: ioBroker.SettableObject = {\n\t\ttype: \"device\",\n\t\tcommon: {\n\t\t\tname: originalObject?.common.name || \"Broadcast\",\n\t\t},\n\t\tnative: {\n\t\t\tbroadcast: true,\n\t\t},\n\t};\n\n\tawait setOrExtendObject(deviceId, desiredObject, originalObject);\n}\n\n/** Removed all objects that belong to a node */\nexport async function removeNode(nodeId: number): Promise<void> {\n\tconst deviceId = `${_.adapter.namespace}.${computeDeviceId(nodeId)}`;\n\ttry {\n\t\tawait _.adapter.delForeignObjectAsync(deviceId);\n\t} catch (e) {\n\t\t/* ok */\n\t}\n\n\t// Find all channel and state objects so we can delete them\n\tconst existingObjs = {\n\t\t...(await _.$$(`${deviceId}.*`, { type: \"channel\" })),\n\t\t...(await _.$$(`${deviceId}.*`, { type: \"state\" })),\n\t};\n\n\tfor (const [id, obj] of entries(existingObjs)) {\n\t\tif (obj.type === \"state\") {\n\t\t\ttry {\n\t\t\t\tawait _.adapter.delForeignStateAsync(id);\n\t\t\t} catch (e) {\n\t\t\t\t/* ok */\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tawait _.adapter.delForeignObjectAsync(id);\n\t\t} catch (e) {\n\t\t\t/* ok */\n\t\t}\n\t}\n}\n\nasync function extendCCInternal(\n\tnode: ZWaveNode | VirtualNode,\n\tchannelId: string,\n\tcc: CommandClasses,\n\tccName: string,\n): Promise<void> {\n\tconst common = {\n\t\tname: ccName,\n\t};\n\tconst native = {\n\t\tcc,\n\t\tversion: node.getCCVersion(cc),\n\t};\n\n\tconst originalObject =\n\t\t_.adapter.oObjects[`${_.adapter.namespace}.${channelId}`];\n\tif (originalObject == undefined) {\n\t\tawait _.adapter.setObjectAsync(channelId, {\n\t\t\ttype: \"channel\",\n\t\t\tcommon,\n\t\t\tnative,\n\t\t});\n\t} else if (\n\t\tJSON.stringify(common) !== JSON.stringify(originalObject.common) ||\n\t\tJSON.stringify(native) !== JSON.stringify(originalObject.native)\n\t) {\n\t\tawait _.adapter.extendObjectAsync(channelId, {\n\t\t\tcommon,\n\t\t\tnative,\n\t\t});\n\t}\n}\n\nexport async function extendCC(\n\tnode: ZWaveNode,\n\tcc: CommandClasses,\n\tccName: string,\n): Promise<void> {\n\tawait extendCCInternal(node, computeChannelId(node.id, ccName), cc, ccName);\n}\n\nexport async function extendVirtualNodeCC(\n\tnode: VirtualNode,\n\tdeviceId: string,\n\tcc: CommandClasses,\n\tccName: string,\n): Promise<void> {\n\tawait extendCCInternal(\n\t\tnode,\n\t\tcomputeVirtualChannelId(deviceId, ccName),\n\t\tcc,\n\t\tccName,\n\t);\n}\n\nexport async function extendValue(\n\tnode: ZWaveNode,\n\targs: ZWaveNodeValueAddedArgs | ZWaveNodeValueUpdatedArgs,\n\tfromCache: boolean = false,\n): Promise<void> {\n\tconst stateId = computeStateId(node.id, args);\n\n\tawait extendMetadata(node, args);\n\ttry {\n\t\tconst state: ioBroker.SettableState = {\n\t\t\tval: safeValue(args.newValue),\n\t\t\tack: true,\n\t\t};\n\t\t// TODO: remove this after JS-Controller 3.2 is stable\n\t\tif (fromCache) {\n\t\t\t// Set cached values with a lower quality (substitute value from device or instance), so scripts can ignore the update\n\t\t\t(state as any).q = 0x40;\n\t\t}\n\t\tif (fromCache) {\n\t\t\t// Avoid queueing too many events when reading from cache\n\t\t\tawait _.adapter.setStateChangedAsync(stateId, state);\n\t\t} else {\n\t\t\tawait _.adapter.setStateAsync(stateId, state);\n\t\t}\n\t} catch (e) {\n\t\t_.adapter.log.error(\n\t\t\t`Cannot set state \"${stateId}\" in ioBroker: ${getErrorMessage(e)}`,\n\t\t);\n\t}\n}\n\nexport async function extendNotificationValue(\n\tnode: ZWaveNode,\n\targs: ZWaveNodeValueNotificationArgs,\n): Promise<void> {\n\tconst stateId = computeStateId(node.id, args);\n\n\tawait extendMetadata(node, args);\n\ttry {\n\t\tconst state: ioBroker.SettableState = {\n\t\t\tval: safeValue(args.value),\n\t\t\tack: true,\n\t\t\texpire: 1,\n\t\t};\n\t\tawait _.adapter.setStateAsync(stateId, state);\n\t} catch (e) {\n\t\t_.adapter.log.error(\n\t\t\t`Cannot set state \"${stateId}\" in ioBroker: ${getErrorMessage(e)}`,\n\t\t);\n\t}\n}\n\nexport async function extendMetadata(\n\tnode: ZWaveNode,\n\targs: ZWaveNodeArgs,\n): Promise<void> {\n\tconst stateId = computeStateId(node.id, args);\n\tconst metadata =\n\t\t(\"metadata\" in args && args.metadata) || node.getValueMetadata(args);\n\n\tawait extendMetadataInternal(stateId, metadata, args, { nodeId: node.id });\n}\n\nexport async function extendVirtualMetadata(\n\tnode: VirtualNode,\n\tdeviceId: string,\n\t{ metadata, ccVersion, ...valueId }: VirtualValueID,\n): Promise<void> {\n\tconst stateId = computeVirtualStateId(deviceId, valueId);\n\tawait extendMetadataInternal(\n\t\tstateId,\n\t\tmetadata,\n\t\tvalueId,\n\t\tnode.id === NODE_ID_BROADCAST\n\t\t\t? {\n\t\t\t\t\tbroadcast: true,\n\t\t\t  }\n\t\t\t: {\n\t\t\t\t\tnodeIds: node.physicalNodes.map((n) => n.id),\n\t\t\t  },\n\t);\n}\n\nasync function extendMetadataInternal(\n\tstateId: string,\n\tmetadata: ValueMetadata,\n\tvalueId: ValueID,\n\tnativePart: Record<string, any> = {},\n) {\n\tconst stateType = valueTypeToIOBrokerType(metadata.type);\n\t// TODO: Try to detect more specific roles depending on the CC type\n\n\tconst originalObject =\n\t\t_.adapter.oObjects[`${_.adapter.namespace}.${stateId}`];\n\n\tconst newStateName =\n\t\t_.adapter.config.preserveStateNames && originalObject?.common.name\n\t\t\t? // Keep the original name if one exists and it should be preserved\n\t\t\t  originalObject.common.name\n\t\t\t: // Otherwise try to construct a new name from the metadata\n\t\t\tmetadata.label\n\t\t\t? `${metadata.label}${\n\t\t\t\t\tvalueId.endpoint ? ` (Endpoint ${valueId.endpoint})` : \"\"\n\t\t\t  }`\n\t\t\t: // and fall back to the state ID if that is missing\n\t\t\t  stateId;\n\n\t// Keep the defined role if the object already exists. Our roles are not good enough for visualizations yet\n\tconst stateRole =\n\t\toriginalObject?.common.role || metadataToStateRole(stateType, metadata);\n\n\tconst objectDefinition: ioBroker.SettableObjectWorker<ioBroker.StateObject> =\n\t\t{\n\t\t\ttype: \"state\",\n\t\t\tcommon: {\n\t\t\t\trole: stateRole,\n\t\t\t\tread: metadata.readable,\n\t\t\t\twrite: metadata.writeable,\n\t\t\t\tname: newStateName,\n\t\t\t\tdesc: metadata.description,\n\t\t\t\ttype: stateType,\n\t\t\t\tmin: (metadata as ValueMetadataNumeric).min,\n\t\t\t\tmax: (metadata as ValueMetadataNumeric).max,\n\t\t\t\tdef: (metadata as ValueMetadataNumeric).default,\n\t\t\t\tunit: (metadata as ValueMetadataNumeric).unit,\n\t\t\t\tstates: (metadata as any).states,\n\t\t\t},\n\t\t\tnative: {\n\t\t\t\t...nativePart,\n\t\t\t\tvalueId: {\n\t\t\t\t\tcommandClass: valueId.commandClass,\n\t\t\t\t\tendpoint: valueId.endpoint,\n\t\t\t\t\tproperty: valueId.property,\n\t\t\t\t\tpropertyKey: valueId.propertyKey,\n\t\t\t\t},\n\t\t\t\tsteps: (metadata as ValueMetadataNumeric).steps,\n\t\t\t} as any,\n\t\t};\n\n\tawait setOrExtendObject(stateId, objectDefinition, originalObject);\n}\n\nexport async function removeValue(\n\tnodeId: number,\n\targs: ZWaveNodeValueRemovedArgs,\n): Promise<void> {\n\tconst stateId = computeStateId(nodeId, args);\n\ttry {\n\t\tawait _.adapter.delObjectAsync(stateId);\n\t} catch {\n\t\t// ignore, the object does not exist\n\t}\n}\n\nfunction valueTypeToIOBrokerType(\n\tvalueType: ValueType,\n): ioBroker.StateCommon[\"type\"] {\n\tswitch (valueType) {\n\t\tcase \"number\":\n\t\tcase \"boolean\":\n\t\tcase \"string\":\n\t\t\treturn valueType;\n\t\tcase \"any\":\n\t\t\treturn \"mixed\";\n\t\tdefault:\n\t\t\tif (valueType.endsWith(\"[]\")) return \"array\";\n\t}\n\treturn \"mixed\";\n}\n\nfunction metadataToStateRole(\n\tstateType: ioBroker.StateCommon[\"type\"],\n\tmeta: ValueMetadata,\n): ioBroker.StateCommon[\"role\"] {\n\tif (stateType === \"number\") {\n\t\treturn meta.writeable ? \"level\" : \"value\";\n\t} else if (stateType === \"boolean\") {\n\t\treturn meta.readable && !meta.writeable ? \"indicator\" : \"switch\";\n\t}\n\treturn \"state\";\n}\n\nexport async function setNodeStatus(\n\tnodeId: number,\n\tstatus: string,\n): Promise<void> {\n\tconst stateId = `${computeDeviceId(nodeId)}.status`;\n\tawait _.adapter.setObjectNotExistsAsync(stateId, {\n\t\ttype: \"state\",\n\t\tcommon: {\n\t\t\tname: \"Node status\",\n\t\t\trole: \"indicator\",\n\t\t\ttype: \"string\",\n\t\t\tread: true,\n\t\t\twrite: false,\n\t\t},\n\t\tnative: {},\n\t});\n\tawait _.adapter.setStateAsync(stateId, status, true);\n}\n\n/** Updates the ready state for the given node */\nexport async function setNodeReady(\n\tnodeId: number,\n\tready: boolean,\n): Promise<void> {\n\tconst stateId = `${computeDeviceId(nodeId)}.ready`;\n\tawait _.adapter.setObjectNotExistsAsync(stateId, {\n\t\ttype: \"state\",\n\t\tcommon: {\n\t\t\tname: \"Ready to use\",\n\t\t\trole: \"indicator\",\n\t\t\ttype: \"boolean\",\n\t\t\tread: true,\n\t\t\twrite: false,\n\t\t\tdef: false,\n\t\t},\n\t\tnative: {},\n\t});\n\tawait _.adapter.setStateAsync(stateId, ready, true);\n}\n\nexport async function setControllerStatistics(\n\tstatistics: ControllerStatistics | null,\n): Promise<void> {\n\tconst stateId = `info.statistics`;\n\tawait _.adapter.setObjectNotExistsAsync(stateId, {\n\t\ttype: \"state\",\n\t\tcommon: {\n\t\t\tname: \"Communication statistics\",\n\t\t\trole: \"indicator\",\n\t\t\ttype: \"object\",\n\t\t\tread: true,\n\t\t\twrite: false,\n\t\t},\n\t\tnative: {},\n\t});\n\tawait _.adapter.setStateAsync(\n\t\tstateId,\n\t\tstatistics ? JSON.stringify(statistics) : null,\n\t\ttrue,\n\t);\n}\n\nexport async function setNodeStatistics(\n\tnodeId: number,\n\tstatistics: NodeStatistics | null,\n): Promise<void> {\n\tconst channelId = `${computeDeviceId(nodeId)}.info`;\n\tconst stateId = `${channelId}.statistics`;\n\tawait _.adapter.setObjectNotExistsAsync(channelId, {\n\t\ttype: \"channel\",\n\t\tcommon: {\n\t\t\tname: \"Information\",\n\t\t},\n\t\tnative: {},\n\t});\n\tawait _.adapter.setObjectNotExistsAsync(stateId, {\n\t\ttype: \"state\",\n\t\tcommon: {\n\t\t\tname: \"Transmission statistics\",\n\t\t\trole: \"indicator\",\n\t\t\ttype: \"object\",\n\t\t\tread: true,\n\t\t\twrite: false,\n\t\t},\n\t\tnative: {},\n\t});\n\tawait _.adapter.setStateAsync(\n\t\tstateId,\n\t\tstatistics ? JSON.stringify(statistics) : null,\n\t\ttrue,\n\t);\n}\n\nexport function computeNotificationId(\n\tnodeId: number,\n\tnotificationLabel: string,\n\teventLabel: string,\n\tproperty?: string,\n): string {\n\treturn [\n\t\tcomputeDeviceId(nodeId),\n\t\tccNameToChannelIdFragment(\"Notification\"),\n\t\t[\n\t\t\tnameToStateId(notificationLabel),\n\t\t\tnameToStateId(eventLabel),\n\t\t\tproperty && nameToStateId(property),\n\t\t]\n\t\t\t.filter((s) => !!s)\n\t\t\t.join(\"_\"),\n\t].join(\".\");\n}\n\nasync function setOrExtendObject(\n\tid: string,\n\tdefinition: ioBroker.SettableObject,\n\toriginal: ioBroker.Object | undefined,\n) {\n\tif (original == undefined) {\n\t\tawait _.adapter.setObjectAsync(id, definition);\n\t} else if (\n\t\tJSON.stringify(definition.common) !== JSON.stringify(original.common) ||\n\t\tJSON.stringify(definition.native) !== JSON.stringify(original.native)\n\t) {\n\t\tawait _.adapter.extendObjectAsync(id, definition);\n\t}\n}\n\nasync function setNotificationValue(\n\tnodeId: number,\n\tnotificationLabel: string,\n\teventLabel: string,\n\tproperty: string | undefined,\n\tvalue: boolean | number | string | Duration = true,\n): Promise<void> {\n\tconst stateId = computeNotificationId(\n\t\tnodeId,\n\t\tnotificationLabel,\n\t\teventLabel,\n\t\tproperty,\n\t);\n\tconst originalObject =\n\t\t_.adapter.oObjects[`${_.adapter.namespace}.${stateId}`];\n\n\tconst newStateName =\n\t\t_.adapter.config.preserveStateNames && originalObject?.common.name\n\t\t\t? // Keep the original name if one exists and it should be preserved\n\t\t\t  originalObject.common.name\n\t\t\t: // Otherwise use the given label (and property name)\n\t\t\t  `${notificationLabel}: ${eventLabel}${\n\t\t\t\t\t!!property ? ` (${property})` : \"\"\n\t\t\t  }`;\n\n\tconst objectDefinition: ioBroker.SettableObjectWorker<ioBroker.StateObject> =\n\t\t{\n\t\t\ttype: \"state\",\n\t\t\tcommon:\n\t\t\t\ttypeof value === \"boolean\"\n\t\t\t\t\t? {\n\t\t\t\t\t\t\trole: \"indicator\",\n\t\t\t\t\t\t\tread: true,\n\t\t\t\t\t\t\twrite: false,\n\t\t\t\t\t\t\tname: newStateName,\n\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t  }\n\t\t\t\t\t: typeof value === \"number\"\n\t\t\t\t\t? {\n\t\t\t\t\t\t\trole: \"value\",\n\t\t\t\t\t\t\tread: true,\n\t\t\t\t\t\t\twrite: false,\n\t\t\t\t\t\t\tname: newStateName,\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t  }\n\t\t\t\t\t: value instanceof Duration\n\t\t\t\t\t? {\n\t\t\t\t\t\t\trole: \"value.interval\",\n\t\t\t\t\t\t\tread: true,\n\t\t\t\t\t\t\twrite: false,\n\t\t\t\t\t\t\tname: newStateName,\n\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\tunit: \"seconds\",\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\trole: \"text\",\n\t\t\t\t\t\t\tread: true,\n\t\t\t\t\t\t\twrite: false,\n\t\t\t\t\t\t\tname: newStateName,\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t  },\n\t\t\tnative: {\n\t\t\t\tnodeId: nodeId,\n\t\t\t\tnotificationEvent: true,\n\t\t\t},\n\t\t};\n\n\t// Translate the value into something useful\n\tlet val;\n\tif (value instanceof Duration) {\n\t\tval = value.toMilliseconds();\n\t\tif (val == undefined) val = \"unknown\";\n\t\telse val /= 1000;\n\t} else {\n\t\tval = value;\n\t}\n\n\tawait setOrExtendObject(stateId, objectDefinition, originalObject);\n\tawait _.adapter.setStateAsync(\n\t\tstateId,\n\t\t{\n\t\t\tval,\n\t\t\texpire: _.adapter.config.notificationEventValidity ?? 1000,\n\t\t},\n\t\ttrue,\n\t);\n}\n\n/** Translates a notification for the Notification CC into states */\nexport async function extendNotification_NotificationCC(\n\tnode: ZWaveNode,\n\targs: ZWaveNotificationCallbackArgs_NotificationCC,\n): Promise<void> {\n\tconst { label, eventLabel, parameters } = args;\n\tif (parameters == undefined) {\n\t\tawait setNotificationValue(node.id, label, eventLabel, undefined, true);\n\t} else if (Buffer.isBuffer(parameters)) {\n\t\tawait setNotificationValue(\n\t\t\tnode.id,\n\t\t\tlabel,\n\t\t\teventLabel,\n\t\t\tundefined,\n\t\t\tparameters.toString(\"hex\"),\n\t\t);\n\t} else if (parameters instanceof Duration) {\n\t\tawait setNotificationValue(\n\t\t\tnode.id,\n\t\t\tlabel,\n\t\t\teventLabel,\n\t\t\tundefined,\n\t\t\tparameters,\n\t\t);\n\t} else {\n\t\tfor (const [key, value] of Object.entries(parameters)) {\n\t\t\tawait setNotificationValue(node.id, label, eventLabel, key, value);\n\t\t}\n\t}\n}\n\nexport async function setRFRegionState(\n\trfRegion: RFRegion | undefined,\n): Promise<void> {\n\tconst stateId = `info.rfRegion`;\n\tawait _.adapter.setObjectNotExistsAsync(stateId, {\n\t\ttype: \"state\",\n\t\tcommon: {\n\t\t\tname: \"RF Region\",\n\t\t\trole: \"info.region\",\n\t\t\ttype: \"number\",\n\t\t\tread: true,\n\t\t\twrite: false,\n\t\t\tstates: enumValuesToMetadataStates(RFRegion),\n\t\t},\n\t\tnative: {},\n\t});\n\tawait _.adapter.setStateAsync(stateId, rfRegion ?? null, true);\n}\n"],
  "mappings": "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",
  "names": []
}
